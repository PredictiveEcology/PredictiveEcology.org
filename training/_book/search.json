[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Robust and nimble scientific workflows, using SpaDES",
    "section": "",
    "text": "Preface\n\n\nAcknowledgements\nWe thank the various contributors, SpaDES developers and SpaDES users that continue to make the open-source ecosystem of SpaDES modules grow.\nWe also thank the Quarto team for their great work."
  },
  {
    "objectID": "NewModuleIntro.html#creating-a-new-module",
    "href": "NewModuleIntro.html#creating-a-new-module",
    "title": "1  New module – Introduction",
    "section": "1.1 Creating a new module",
    "text": "1.1 Creating a new module"
  },
  {
    "objectID": "NewModuleIntro.html#new-module-introduction",
    "href": "NewModuleIntro.html#new-module-introduction",
    "title": "1  New module – Introduction",
    "section": "1.2 New Module Introduction",
    "text": "1.2 New Module Introduction\nSpaDES modules are comprised of R code that has metadata and the gets put into functions. With this in mind, we can start with some simple R code.\nWe will start by thinking about metadata: What is metadata?\nWe can examine the following code chunk. First, we ask: what are the inputs and the outputs?\n\n\nCode\n# create some data\nx &lt;- y + rnorm(10)\n# fit a linear model\nout &lt;- lm(x ~ y)\n\n# plot the fit\nplot(out)\n\n\nThe inputs to this chunk are just one: the object y. This code will not work (i.e., it will cause an error) if y is not defined. The outputs are x and out. Both of these are created within this chunk.\nNext, what are the package dependencies?. We see that there are two functions: rnorm and lm. We don’t know what packages they are in, so we can find out by typing them at the R prompt. At the bottom, it says that the function rnorm is in the stats package. Fortunately for us, this is a default (“base”) package in R and it is always pre-loaded. So, nothing to do here.\n\n\nCode\n&gt; rnorm\nfunction (n, mean = 0, sd = 1) \n...\n&lt;environment: namespace:stats&gt;\n\n\nSo, our metadata are:\n\nInputs: y\nOutputs: x, out\nPackage dependencies: Base packages only\n\nWe will next put them into the correct places in the new SpaDES module."
  },
  {
    "objectID": "NewModuleIntro.html#make-the-module",
    "href": "NewModuleIntro.html#make-the-module",
    "title": "1  New module – Introduction",
    "section": "1.3 Make the module",
    "text": "1.3 Make the module\nNow we use the SpaDES function newModule to make a new module. (see )\n\n\nCode\nSpaDES.core::newModule(name = \"My_linear_model\", path = \".\")\n\n\nThis will create a new folder with several files in it. See ?newModule for details. For now, run the above and open the .R that is created."
  },
  {
    "objectID": "NewModuleIntro.html#edit-metadata",
    "href": "NewModuleIntro.html#edit-metadata",
    "title": "1  New module – Introduction",
    "section": "1.4 Edit metadata",
    "text": "1.4 Edit metadata\nScroll down to where it says inputObjects and expectsInputs. We will put y there.\n\n\nCode\ninputObjects = bindrows(\n    expectsInput(objectName = \"y\", objectClass = \"numeric\", desc = \"The inputs for the linear model\", sourceURL = NA)\n  )\n\n\nNext, scroll down to where it says outputObjects and createsOutput. We will put x and out there. Don’t forget a comma at the end of each createsOutput as these are arguments to bindrows\n\n\nCode\noutputObjects = bindrows(\n    createsOutput(objectName = \"x\", objectClass = \"numeric\", desc = \"The randomly created varible that is used as a response variable\"),\n    createsOutput(objectName = \"out\", objectClass = \"lm\", desc = \"A linear model object from the equation (x ~ y)\")\n  )"
  },
  {
    "objectID": "NewModuleIntro.html#put-code-in-init-function",
    "href": "NewModuleIntro.html#put-code-in-init-function",
    "title": "1  New module – Introduction",
    "section": "1.5 Put code in Init function",
    "text": "1.5 Put code in Init function\nFirst, we move the first two lines of code into a function. We will choose the Init function. We will discuss why in a bit.\n\n\nCode\nInit &lt;- function(sim) {\n  x &lt;- y + rnorm(10)\n  out &lt;- lm(x ~ y)\n  return(invisible(sim))\n}"
  },
  {
    "objectID": "NewModuleIntro.html#sharing-inputs-and-outputs",
    "href": "NewModuleIntro.html#sharing-inputs-and-outputs",
    "title": "1  New module – Introduction",
    "section": "1.6 Sharing inputs and outputs",
    "text": "1.6 Sharing inputs and outputs\nYou may have noticed that the Init function template defines a function with a sim argument. This is an object we haven’t learned about yet; we will just think of it as a list where we can put objects we want to share with other modules or “just keep them for later”, such as our inputs and outputs.\nTo share these objects, we assign them to the sim list using the normal R notations. We have to make this modification 5 times for every instance of our inputs and outputs\n\n\nCode\nInit &lt;- function(sim) {\n  sim$x &lt;- sim$y + rnorm(10)\n  sim$out &lt;- lm(sim$x ~ sim$y)\n  return(invisible(sim))\n}\n\n\nNow we have a module that creates two objects, x and out and puts them in the sim objects. This all happens in a function called Init. Next: the plot(out)"
  },
  {
    "objectID": "NewModuleIntro.html#events",
    "href": "NewModuleIntro.html#events",
    "title": "1  New module – Introduction",
    "section": "1.7 Events",
    "text": "1.7 Events\nWe can look at our 3 lines of example and think, “this is 2 steps: a first that does the model and a second that plots it” (of course, you can divide this up in several ways; we will go with this for now.).\nWe can call the 2 steps, events and imagine we could run them in sequence… first, lets put the plot in a function. We will choose the plotFun function. We will also add the sim$ because the out will be shared because it is in the sim “list”.\n\n\nCode\nplotFun &lt;- function(sim) {\n  plot(sim$out)\n  return(invisible(sim))\n}\n\n\nThe template already has some default code that actually puts the events in an order without us needing to do anything. It also has a parameter that determines whether the plot will happen or not. We will just accept the defaults for now."
  },
  {
    "objectID": "NewModuleIntro.html#default-values",
    "href": "NewModuleIntro.html#default-values",
    "title": "1  New module – Introduction",
    "section": "1.8 Default Values",
    "text": "1.8 Default Values\nRecall, we don’t have a value for y. This means that if you run the following, you will get an error:\n\n\nCode\nSpaDES.core::simInitAndSpades(modules = \"My_linear_model\", paths = list(modulePath = \"tutos/NewModuleIntro\"))\n\n\nJust like functions in R, we can supply default values for our inputs. We put these in a function at the bottom called .inputObjects.\nCopy this to the module, replacing the .inputObjects function.\n\n\nCode\n.inputObjects &lt;- function(sim) {\n  if (!suppliedElsewhere(\"y\", sim))\n    sim$y &lt;- rnorm(10, mean = 20, sd = 2)\n  return(invisible(sim))\n}"
  },
  {
    "objectID": "NewModuleIntro.html#run-the-new-module",
    "href": "NewModuleIntro.html#run-the-new-module",
    "title": "1  New module – Introduction",
    "section": "1.9 Run the new module",
    "text": "1.9 Run the new module\nNow, we have inputs and outputs defined, our code has been place in 2 spots, and we have default value for y.\n\n\nCode\nSpaDES.core::simInitAndSpades(modules = \"My_linear_model\", paths = list(modulePath = \"tutos/NewModuleIntro\"))\n\n\nWe now have a SpaDES module that has metadata, generates random starting data (if the user doesn’t supply an alternative), fits a linear model, outputs that model, and plots the fit."
  },
  {
    "objectID": "NewModuleIntro.html#questions",
    "href": "NewModuleIntro.html#questions",
    "title": "1  New module – Introduction",
    "section": "1.10 Questions",
    "text": "1.10 Questions\n\nWhat are some things we “gained” from putting our simple 3 lines of code into a module?\n\nWe can turn off plotting easily. Set .plotInitialTime = NA in the simInitAndSpades call.\n\nWhat are some things we “lost”?\n\nMore complicated. (overkill for these 3 lines?)\n\nWhat if we used an R package that wasn’t in the base packages list?\n\nSee ?defineModule for all the metadata items. Specifically, see reqdPkgs.\n\nWhat is the sim? See ?'.simList-class'"
  },
  {
    "objectID": "NewModuleIntro.html#see-also",
    "href": "NewModuleIntro.html#see-also",
    "title": "1  New module – Introduction",
    "section": "1.11 See also",
    "text": "1.11 See also\nSee also: ?expectsInput, ?createsOutput, ?simInitAndSpades, ?newModule"
  },
  {
    "objectID": "ModulesAndEvents.html#modules-vs.-events",
    "href": "ModulesAndEvents.html#modules-vs.-events",
    "title": "2  Modules, Events and Functions",
    "section": "2.1 Modules vs. Events",
    "text": "2.1 Modules vs. Events\nA module is a collection of R scripts that includes:\n\ndefineModule (mandatory)\ndoEvent.*moduleName* function (mandatory)\nother functions (optional)\na documentation file (moduleName.rmd)\n\nThese are all contained within a file structure like this, with other optional files:\n/moduleRepository\n  |_ moduleName/\n      |_ R/                     # contains additional .R (helper) files\n      |_ data/                  # directory for all included data\n          |_ CHECKSUMS.txt      # contains checksums for data files\n      |_ tests/                 # contains unit tests for module code\n      |_ citation.bib           # bibtex citation for the module\n      |_ LICENSE.txt            # describes module's legal usage\n      |_ moduleName.R           # module code file (incl. metadata)\n      |_ moduleName.Rmd         # documentation, usage info, etc.\n\n2.1.1 Events\nEvents are named chunks of code that can be scheduled to be run once or many times. These are scheduled with scheduleEvent. There are several commonly occurring module types that can be grouped based on the events that they contain.\n\n\n2.1.2 Functions\nEssentially, everything in R is or uses functions. Modules define functions (doEvent.*moduleName*), events call specific functions, and functions can be defined within modules, R packages, or user code.\n\n2.1.2.1 Key functions in the SpaDES ecosystem\nIn re-useable workflows, functions become particularly effective if they:\n\nAre rerun-tolerant, meaning the first time they run they “do” something, but the second and subsequent times, they give the same output as the first time, but they skip the “doing” part\nCan be run from any person’s computer and “work”, i.e., give the same result\n\nTwo key functions help achieve these points, Cache and prepInputs\n\n\n2.1.2.2 Cache\nCache is a function that can be wrapped around other functions that turns that function into a rerun-tolerant function. reproducible::Cache has several important modifications that work for some objects that don’t cache well using “normal” caching, such as terra objects that are actually pointers to locations on disk rather than normal R objects.\n\n\nCode\nlibrary(reproducible)\n\na &lt;- rnorm(1e7)\nb &lt;- rnorm(1e7) |&gt; Cache()\n\n\nSee ?reproducible::Cache\n\n\n2.1.2.3 prepInputs\n?reproducible::prepInputs\nFor more information\n\n\n2.1.2.4 Module types, based on Events and Functions used\n\nData preparation modules may have:\n\none (maybe just the “init” event) or few events and their primary goal is to get and deal with data\nDo GIS operations\nUse reproducible::prepInputs\n\nDynamic modules\n\nmodules that repeat certain events\nmodules that use explicit iterations or time and whose inputs can vary each time\n\nData Visualization modules"
  },
  {
    "objectID": "ModulesAndEvents.html#questions",
    "href": "ModulesAndEvents.html#questions",
    "title": "2  Modules, Events and Functions",
    "section": "2.2 Questions",
    "text": "2.2 Questions"
  },
  {
    "objectID": "ModulesAndEvents.html#see-also",
    "href": "ModulesAndEvents.html#see-also",
    "title": "2  Modules, Events and Functions",
    "section": "2.3 See also",
    "text": "2.3 See also\nSee also: Section 3.1, ?scheduleEvent, ?P, ?time, ?start, ?end"
  },
  {
    "objectID": "ModulesAndEvents.html#more-learning-on-this-subject",
    "href": "ModulesAndEvents.html#more-learning-on-this-subject",
    "title": "2  Modules, Events and Functions",
    "section": "2.4 More learning on this subject",
    "text": "2.4 More learning on this subject\nMy First Module\nCreating a seed dispersal module"
  },
  {
    "objectID": "Scheduling.html#sec-schedulingEvents",
    "href": "Scheduling.html#sec-schedulingEvents",
    "title": "3  Scheduling events",
    "section": "3.1 Scheduling events in SpaDES",
    "text": "3.1 Scheduling events in SpaDES\nSee New Module Introducion for creation of a simple module.\nHere, we will talk about scheduling events.\nScheduling events allows us to control when things happen in a sequnence. This can be as simple as “this module will just do one thing” to “this module will do several things, some of which repeat”. We will use a simple example where there is one thing that happens “once” and one thing that happens several times. In “normal” R-speak, we will write a loop.\nReturn to example in New Module Introducion. This time, we will predict from the linear model, with updated values of the y. In this simple example, we will pretend that each prediction is “one year into the future” and that our y will slowly get bigger.\n\n\nCode\n# .inputObjects ##############\ny &lt;- rnorm(10)\n\n# Init #####\nx &lt;- y + rnorm(10)\n# fit a linear model\nout &lt;- lm(x ~ y)\npred &lt;- list()\n\n# Prediction #####\nstartYear &lt;- 2023\nyears &lt;- startYear:(startYear + 10) + 1\nfor (year in years - startYear) {\n  pred[[year]] &lt;- predict(out, newdata = data.frame(y = rnorm(10) + year))\n}\n\n# Plot ####\npredictions &lt;- data.frame(year = rep(years, each = 10), prediction = unlist(pred))\n# plot the predictions\nggplot(predictions, aes(x = year, y = prediction, colour = year)) + geom_point() + geom_smooth()\n\n\n\n\n\nIn the above code, there are 4 sections. These will each be copied into the SpaDES module below, in their respective sections. We have added 1 new section, called “Prediction”."
  },
  {
    "objectID": "Scheduling.html#convert-to-a-module",
    "href": "Scheduling.html#convert-to-a-module",
    "title": "3  Scheduling events",
    "section": "3.2 Convert to a module",
    "text": "3.2 Convert to a module\n\n\nCode\nSpaDES.core::newModule(name = \"scheduling\", path = \".\")\n\n\nOpen the module file, which will be printed in the console. We can scroll down to the Init function. Copy the Init, the .inputObjects, the Plot part into the new modules, as we did in New Module Introducion.\nWe must make the same decisions about “local” that are OK if they don’t get keps and “global” objects that we want to keep. These global objects get put into sim. Your new module should have these 3 new sections:\n\n\nCode\nInit &lt;- function(sim) {\n  x &lt;- sim$y + rnorm(10)\n  # fit a linear model\n  sim$out &lt;- lm(x ~ sim$y)\n  sim$pred &lt;- list()\n}\n\nplotFun &lt;- function(sim) {\n  sim$predictions &lt;- data.frame(year = rep(sim$years, each = 10), prediction = unlist(sim$pred))\n  # plot the predictions\n  sim$gg &lt;- ggplot(sim$predictions, aes(x = year, y = prediction, colour = year)) + geom_point() + geom_smooth()\n  print(sim$gg)\n}\n\n.inputObjects &lt;- function(sim) {\n  sim$y &lt;- rnorm(10)\n}"
  },
  {
    "objectID": "Scheduling.html#new-event-function-prediction",
    "href": "Scheduling.html#new-event-function-prediction",
    "title": "3  Scheduling events",
    "section": "3.3 New Event Function – Prediction",
    "text": "3.3 New Event Function – Prediction\nThe new part is the for loop. This part takes new covariates (new values for y) that emulates “predicted” covariates, derives a newly predicted x, and we then keep these predicted x values each year.\nWe use scheduleEvent to do this. Copy the Prediction part into a new function:\n\n\nCode\nPrediction &lt;- function(sim) {\n  startYear &lt;- 2023\n  sim$years &lt;- startYear:(startYear + 10) + 1\n  for (year in sim$years - startYear) {\n    sim$pred[[year]] &lt;- predict(sim$out, newdata = data.frame(y = rnorm(10) + year))\n  }\n  return(invisible(sim))\n}"
  },
  {
    "objectID": "Scheduling.html#scheduling",
    "href": "Scheduling.html#scheduling",
    "title": "3  Scheduling events",
    "section": "3.4 Scheduling",
    "text": "3.4 Scheduling\nNow we need to tell SpaDES when to do each of the steps or “events”. The Init, we do once, at the start. The plotFn we do once, but this time it is at the “end”. The .inputObjects always happens once and “before the start”. The last part (i.e., the prediction event) must happen 10 times, and it must start after Init and before the plotFn.\n\n3.4.1 doEvent\nThere is a special function in a SpaDES module called doEvent. SpaDES calls this function once, passing the argument event = \"init\". That means that R will enter into this function only once and run only the init part, unless we specifically tell it to do more. We use the scheduleEvent function. We place this function anywhere we want, in general. In this example, we will place it in a few places.\n\n3.4.1.1 In the init\nWe look at the init event and we see 2 scheduleEvent calls that come with the template. We will use those to learn. In each “event”, we often see one part that “does something” and another part that “schedules something”. In the default template, we “do” the Init function and we schedule plot and save. We can delete the save event, as we won’t do that here. But we will replace it with “schedule prediction”\nSee ?start, ?scheduleEventhttps://rdrr.io/cran/SpaDES.core/man/scheduleEvent.html, ?P\n\n\nCode\nsim &lt;- Init(sim)\n\n# schedule future event(s)\nsim &lt;- scheduleEvent(sim, P(sim)$.plotInitialTime, \"scheduling\", \"plot\")\n# sim &lt;- scheduleEvent(sim, P(sim)$.saveInitialTime, \"scheduling\", \"save\")\n\n# here we create a new event type == \"predictions\" and we schedule it for `start(sim)`\nsim &lt;- scheduleEvent(sim, start(sim), \"scheduling\", \"predictions\") \n\n\nCopy the above code chunk to the init section so that it looks like this:\n\n\nCode\nswitch(\n    eventType,\n    init = {\n      sim &lt;- Init(sim)\n      \n      # schedule future event(s)\n      sim &lt;- scheduleEvent(sim, P(sim)$.plotInitialTime, \"scheduling\", \"plot\")\n      # sim &lt;- scheduleEvent(sim, P(sim)$.saveInitialTime, \"scheduling\", \"save\")\n      \n      # here we create a new event type == \"predictions\" and we schedule it for `start(sim)`\n      sim &lt;- scheduleEvent(sim, start(sim), \"scheduling\", \"predictions\") \n    }\n\n\n\n\n\n3.4.2 The new event\nWe add code to make a new event, called \"predictions\" (it must match what we wrote in the scheduleEvent). In this event, we “do” the prediction, then we schedule the next prediction at “time plus 1”\nSee ?time.\n\n\nCode\npredictions = {\n  # do the Prediction\n  sim &lt;- Prediction(sim)\n  \n  # schedule the next Prediction\n  sim &lt;- scheduleEvent(sim, time(sim) + 1, \"scheduling\", \"predictions\") \n}\n\n\n\n\n3.4.3 Double check existing events\nIf we ran the above changes, we would see an error because the plotFn is, by default, scheduled to run at the time that is specified by .plotInitialTime, which by default is start(sim). We have no data yet at that time. So, we have to update the\n\n\nCode\nscheduleEvent(sim, end(sim), \"scheduling\", \"plot\")\n\n\n\n\n3.4.4 Update module metadata\nLike in New Module Introducion, we have to update the module metadata … what are the inputs, outputs, parameters. SpaDES will not error if the metadata are not correct, but it will try to point out the problems."
  },
  {
    "objectID": "Scheduling.html#run",
    "href": "Scheduling.html#run",
    "title": "3  Scheduling events",
    "section": "3.5 Run",
    "text": "3.5 Run\nThe resulting module can now be run.\n\n\nCode\nSpaDES.core::simInitAndSpades(modules = \"scheduling\", paths = list(modulePath = \".\"))\n\n\nA complete version of this new module can be found at scheduling.R. You can copy this over top of the new module that you created here, i.e., keep the same folder structure."
  },
  {
    "objectID": "Scheduling.html#questions",
    "href": "Scheduling.html#questions",
    "title": "3  Scheduling events",
    "section": "3.6 Questions",
    "text": "3.6 Questions\n\nhow are some ways that scheduleEvent is different from a “loop”?\n\nWe can change the “step” length between events.\nWe can interweave events, e.g., a fire event then a tree growth event\n\nWhen is a loop better than scheduling?\n\nLoops are much faster than scheduling.\nBut really, avoid loops in R if you can help it\n\nChances are that the first versions of this module didn’t work. How do you fix it?\n\nLearn how to debug in R and SpaDES"
  },
  {
    "objectID": "Scheduling.html#see-also",
    "href": "Scheduling.html#see-also",
    "title": "3  Scheduling events",
    "section": "3.7 See also",
    "text": "3.7 See also\nSee also: ?scheduleEvent, ?P, ?time, ?start, ?end"
  },
  {
    "objectID": "Scheduling.html#more-learning-on-this-subject",
    "href": "Scheduling.html#more-learning-on-this-subject",
    "title": "3  Scheduling events",
    "section": "3.8 More learning on this subject",
    "text": "3.8 More learning on this subject\nMy First Module\nCreating a seed dispersal module"
  },
  {
    "objectID": "simList.html#sec-simlist",
    "href": "simList.html#sec-simlist",
    "title": "4  simList – What is in it?",
    "section": "4.1 The simList",
    "text": "4.1 The simList\nIn R, there is a default environment, called the .GlobalEnv. When you start typing in R and you create an object, it is “put” in the .GlobalEnv\n\n\nCode\n# this is in the .GlobalEnv\na &lt;- 1\nenvironment()\n\n\nThis .GlobalEnv is convenient to begin in R, but it quickly becomes limiting. We need more places to put objects, and we need a way to be more in control of the things that we want to keep, share, modify etc. In SpaDES, this place is called the simList. It is a rich data object that acts like a list or an environment, i.e., we can put objects into it and use them later.\n\n\nCode\nsim &lt;- simInit()\nsim$a &lt;- 1\nsim$b &lt;- sim$a + 2\nsim$b\nenvir(sim)"
  },
  {
    "objectID": "simList.html#where-does-simlist-come-from",
    "href": "simList.html#where-does-simlist-come-from",
    "title": "4  simList – What is in it?",
    "section": "4.2 Where does simList come from?",
    "text": "4.2 Where does simList come from?\nThere are 2 main ways in SpaDES.core to create a simList:\n\nusing simInit() creates a simList object.\nusing spades() , which returns a modified simList object."
  },
  {
    "objectID": "simList.html#how-can-we-specify-a-simlist",
    "href": "simList.html#how-can-we-specify-a-simlist",
    "title": "4  simList – What is in it?",
    "section": "4.3 How can we specify a simList?",
    "text": "4.3 How can we specify a simList?\nA simList object is simply a structured data type containing various elements.\nThe main components of a simList are:\n\nA list of modules used;\nThe event queue;\nA description of the data (object) dependencies."
  },
  {
    "objectID": "simList.html#how-spades-works-simlists",
    "href": "simList.html#how-spades-works-simlists",
    "title": "4  simList – What is in it?",
    "section": "4.4 How SpaDES works: simLists",
    "text": "4.4 How SpaDES works: simLists\nWe can examine the simList object structure in the usual R fashion by printing (showing) it, or by using str():\n\n\nCode\nemptySim &lt;- simInit()\nemptySim  # same as show(emptySim)\nstr(emptySim)\n\n\nNOTE: simLists are S4 objects, so we can use getSlots() and slotNames() to examine the object.\nSee also ?'.simList-class'"
  },
  {
    "objectID": "simList.html#accessing-the-parts-of-a-simlists",
    "href": "simList.html#accessing-the-parts-of-a-simlists",
    "title": "4  simList – What is in it?",
    "section": "4.5 Accessing the parts of a simLists",
    "text": "4.5 Accessing the parts of a simLists\n\n\n\nSetting:\n  options(\n    reproducible.cachePath = '/tmp/RtmpqooyGz/reproducible/cache'\n    spades.inputPath = '/tmp/RtmpqooyGz/SpaDES/inputs'\n    spades.outputPath = '/tmp/RtmpqooyGz/SpaDES/outputs'\n    spades.modulePath = '/tmp/RtmpqooyGz/SpaDES/modules'\n    spades.scratchPath = '/tmp/RtmpqooyGz/SpaDES/scratch'\n  )\n\n\nMay07 16:11:38 simInit Using setDTthreads(1). To change: 'options(spades.DTthreads = X)'.\n\n\nElpsed time for simInit: 0.02416015 secs\n\n\n\n\n\nslot\naccessor\n\n\n\n\nmodules\nmodules()\n\n\nparams\nparams()\n\n\nevents\nevents()\n\n\ncurrent\ncurrent()\n\n\ncompleted\ncompleted()\n\n\ndepends\ndepends()\n\n\nsimtimes\ntimes()\n\n\ninputs\ninputs()\n\n\noutputs\noutputs()\n\n\npaths\npaths()\n\n\n.envir\nenvir()\n\n\n.xData\nobjects()\n\n\n\n\n\n\n\n\n\n\n\n\nother_accessors\n\n\n\n\npackages()\n\n\nglobals()\n\n\nstart()\n\n\nend()\n\n\ntimeunit()\n\n\ntimeunits()\n\n\npaths()\n\n\ncachePath()\n\n\ninputPath()\n\n\noutputPath()\n\n\nmodulePath()"
  },
  {
    "objectID": "simList.html#model-specification",
    "href": "simList.html#model-specification",
    "title": "4  simList – What is in it?",
    "section": "4.6 Model specification",
    "text": "4.6 Model specification\nSimple examples (using demo modules) of simInit() and spades() calls.\n\nexamine simList structure before and after the spades() call\n\n\n4.6.1 Initiliaze an empty simList object\n\n\nCode\nemptySim &lt;- simInit()\n\n\n\n\nSetting:\n  options(\n    reproducible.cachePath = '/tmp/RtmpqooyGz/reproducible/cache'\n    spades.inputPath = '/tmp/RtmpqooyGz/SpaDES/inputs'\n    spades.outputPath = '/tmp/RtmpqooyGz/SpaDES/outputs'\n    spades.modulePath = '/tmp/RtmpqooyGz/SpaDES/modules'\n    spades.scratchPath = '/tmp/RtmpqooyGz/SpaDES/scratch'\n  )\n\n\nMay07 16:11:39 simInit Using setDTthreads(1). To change: 'options(spades.DTthreads = X)'.\n\n\nElpsed time for simInit: 0.01543689 secs\n\n\n\n\n4.6.2 Inspect the empty simList object\n\nWhat are the names of each of the slots in the simList?\nWhat do each of these slots contain? Hint: see ?.simList-class\n\n\n\nCode\nstr(emptySim)\nslotNames(emptySim)\ngetSlots('simList')\n?'.simList-class'\n\n\n\n\n4.6.3 Inspect the new simList object\nUse the simList accessor functions to determine the following:\n\nthe modules included in the simulation and their package dependencies;\nthe global parameter values used;\nthe module-specific parameter values used;\nthe simulation start and end times;\nthe timeunits used by the modules in the simulation;\nthe scheduled and completed event queues;\nthe objects (functions, data, etc.) used in the simulation;\nthe file paths used for simulation inputs and outputs.\n\n\n\nCode\n# list modules used in the simulation\nmodules(mySim)\n\n# list module dependencies and packages used\ndepends(mySim)\npackages(mySim)\n\n# list global and module-specific param values\nglobals(mySim)\nparams(mySim)\nP(mySim)       ## bonus: how do params() and P() differ?\n\n# list start and end times\ntimes(mySim)\nstart(mySim)\nend(mySim)\n\n# get the simulation and module timeunits\ntimeunit(mySim)\ntimeunits(mySim)\n\n# get the scheduled and completed event queues\nevents(mySim)\ncompleted(mySim)\n\n# list the objects (functions, data, etc.) stored in the simList\nobjects(mySim)\n\n# list the file paths used in the simulation\npaths(mySim)\ninputPath(mySim)\noutputPath(mySim)\n\n\n\n\n4.6.4 Run the simulation\n\n\nCode\ndev()\nmySimOut &lt;- Copy(mySim) ## make a deep copy of the simList\nmySimOut &lt;- spades(mySimOut)\n\n\n\n\n4.6.5 Compare the simList before and after\n\n\nCode\ntimes(mySim)\ntimes(mySimOut)\n\nobjects(mySim)\nobjects(mySimOut)"
  },
  {
    "objectID": "simList.html#see-also",
    "href": "simList.html#see-also",
    "title": "4  simList – What is in it?",
    "section": "4.7 See also",
    "text": "4.7 See also\n?.simList-class ?simInit ?spades"
  },
  {
    "objectID": "realexamples.html",
    "href": "realexamples.html",
    "title": "“Real-world” examples of SpaDES workflows",
    "section": "",
    "text": "This section will take you through several “real-world” examples that use SpaDES to build and execute a workflow. By “real-world” we mean workflows that use models that have been/are used in research or application.\nBecause we will not explain each model or the SpaDES modules in detail, we encourage learning more about these models from the sources noted in the chapters.\nIn this section we assume that readers are familiar with SpaDES, namely creating and using SpaDES modules. If not, we encourage going through the chapters in SpaDES 101."
  },
  {
    "objectID": "castorExample.html#workflow-setup",
    "href": "castorExample.html#workflow-setup",
    "title": "5  Castor workflow with setupProject",
    "section": "5.1 Workflow setup",
    "text": "5.1 Workflow setup\nSpaDES.project functions expect SpaDES modules to either exist locally, or at root level of separate repositories. This is not the case with Castor modules, which are in a nested folder (i.e. a folder in a folder tree) of a single GitHub repository.\nSpaDES.project will eventually be able to deal with this1, but for now we work around this issue by using a custom function called getCastorModulesAndDB. This function will also download the demo SQLite database from Google Drive2. You’ll be prompted to authorise this operation and a browser window will open for this. Make sure you give tidyverse read/write access to your files:\n\n\n\n\n\nFigure 5.1: ?(caption)\n\n\n\n\nAfter the “workaround” setupProject does all the heavy-lifting of setting up the workflow, namely installing all package dependencies listed in the several modules and in setupProject(..., packages), creating all the necessary folders, sourcing additional files and creating parameter, inputs and outputs lists – see ?setupProject.\n\n\nCode\n## install/load necessary packages\nrepos &lt;- c(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))\ninstall.packages(c(\"remotes\", \"reproducible\", \"googledrive\"), repos = repos)\nremotes::install_github(\"PredictiveEcology/SpaDES.project@transition\")   ## to deal with modules in nested GH folders.\nlibrary(SpaDES.project)\n\n## get Castor modules and functions\nsetupFunctions(paths = list(\"projectPath\" = \"~/\"),\n               functions = c(\"PredictiveEcology/PredictiveEcology.org@training-book/tutos/castorExample/getCastorModulesAndDB.R\",\n                             \"PredictiveEcology/PredictiveEcology.org@training-book/tutos/castorExample/params.R\"),\n               overwrite = TRUE)\noutMod &lt;- getCastorModulesAndDB(paths = list(\"modulePath\" = \"~/tutos/castorExample/modules/\",\n                                             \"projectPath\" = \"~/tutos/castorExample\"),\n                                modules = c(\"dataCastor\", \n                                            \"growingStockCastor\", \n                                            \"forestryCastor\", \n                                            \"blockingCastor\"),\n                                dbURL = \"https://drive.google.com/file/d/1-2POunzC7aFbkKK5LeBJNsFYMBBY8dNx/view?usp=sharing\",\n                                dbPath = \"~/tutos/castorExample/R/scenarios/comparison_stsm\")\n\n## set up the workflow paths, dependencies and modules\n## as well as simulation parameters, (some) inputs and outputs\nout &lt;- setupProject(\n  paths = list(\"inputPath\" = \"modules/forestryCastor/inputs\",\n               \"outputPath\" = \"R/scenarios/comparison_stsm/outputs\",\n               \"modulePath\" = \"modules/\",\n               \"cachePath\" = \"modules/forestryCastor\",\n               \"projectPath\" = \"~/tutos/castorExample\"),\n  modules = names(outMod$modules),\n  functions = \"bcgov/castor@main/R/functions/R_Postgres.R\",\n  ## install and load\n  require = \"dplyr\",\n  ## install but don't load these:\n  packages = c(\n    \"DBI\", \n    \"DiagrammeR\",\n    \"keyring\",\n    \"rgdal\", \n    \"RPostgreSQL\", \n    \"sp\",\n    \"terra\"\n  ),\n  params = \"params.R\",\n  times = list(start = 0, end = 20),\n  outputs = {\n    data.frame(objectName = c(\"harvestReport\",\n                              \"growingStockReport\"))\n  },\n  scenario = {\n    data.table(name = \"stsm_base_case\",\n               description = paste(\"Priority queue = oldest first. Adjacency constraint\",\n                                   \"= None. Includes roads (mst) and blocks (pre).\",\n                                   \"Harvest flow = 147,300 m3/year in decade 1, 133,500\",\n                                   \"m3/year in decade 2, 132,300 m3/year in decades 3 to\",\n                                   \"14 and 135,400 m3/year in decades 15 to 25.\",\n                                   \"Minimum harvest age = 80 and minimum harvest volume = 150\"))\n  },\n  harvestFlow = {\n    rbindlist(list(data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 1,\n                                                 to = 1, \n                                                 by = 1),\n                                            1), \n                              flow = 1473000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 2,\n                                                 to = 2, \n                                                 by = 1),\n                                            1), \n                              flow = 1335000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 3,\n                                                 to = 14, \n                                                 by = 1),\n                                            1), \n                              flow = 1323000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 15,\n                                                 to = 25, \n                                                 by = 1),\n                                            1), \n                              flow = 1354000, \n                              partition_type = 'live')  \n    ))\n  },\n  Restart = TRUE\n)"
  },
  {
    "objectID": "castorExample.html#initialise-the-model-and-inspect-simlist",
    "href": "castorExample.html#initialise-the-model-and-inspect-simlist",
    "title": "5  Castor workflow with setupProject",
    "section": "5.2 Initialise the model and inspect simList",
    "text": "5.2 Initialise the model and inspect simList\nsetupProject() returns a names list containing values that can be passed as argument to simInit()3.\nWe use do.call() to pass the whole list of arguments to simInit.\n\n\nCode\n## initialize simulation\ncastorInit &lt;- do.call(SpaDES.core::simInit, out)\n\n\nAnother (more verbose) option would to call simInit directly:\n\n\nCode\ncastorInit &lt;- SpaDES.core::simInit(\n  times = out$times,\n  params = out$params, \n  modules = out$modules, \n  objects = list(scenario = out$scenario, \n                 harvestFlow = out$harvestFlow)\n)\n\n\nUse the following functions to access workflow/model properties. events(), for instance will output the scheduled events, which at this point are only the init events of each module as you can see in the output below.\n\n\nCode\n## inspect the `simList`\nSpaDES.core::params(castorInit) \nSpaDES.core::inputs(castorInit)\nSpaDES.core::outputs(castorInit)\nSpaDES.core::times(castorInit) \n\n## scheduled events\nSpaDES.core::events(castorInit) \n\n\n\n\n   eventTime         moduleName eventType eventPriority\n       &lt;num&gt;             &lt;char&gt;    &lt;char&gt;         &lt;num&gt;\n1:         0         checkpoint      init             0\n2:         0               save      init             0\n3:         0           progress      init             0\n4:         0               load      init             0\n5:         0         dataCastor      init             1\n6:         0 growingStockCastor      init             1\n7:         0     blockingCastor      init             1\n8:         0     forestryCastor      init             1"
  },
  {
    "objectID": "castorExample.html#visualize-the-workflow",
    "href": "castorExample.html#visualize-the-workflow",
    "title": "5  Castor workflow with setupProject",
    "section": "5.3 Visualize the workflow",
    "text": "5.3 Visualize the workflow\nmoduleDiagram() and objectDiagram() are great to visualise how each module interacts with the other. Recall that these interactions arise from object “exchanges” between modules, which are deduced by simInit() from module metadata (Figure 5.3) – i.e., if a module’s inputs are another’s outputs, then the first module will follow the second.\n\n\nCode\nSpaDES.core::moduleDiagram(castorInit)\nSpaDES.core::objectDiagram(castorInit)\n\n\n\n\n\n\n\nFigure 5.2: Diagram of module connections.\n\n\n\n\n\n\n\n\n\nFigure 5.3: Diagram of module inter-dependencies with object names."
  },
  {
    "objectID": "castorExample.html#run-simulation",
    "href": "castorExample.html#run-simulation",
    "title": "5  Castor workflow with setupProject",
    "section": "5.4 Run simulation",
    "text": "5.4 Run simulation\nspades() runs the simulation, beginning with the execution of the init events. Notice how the result of outputs() differs from previously.\n\n\nCode\ncastorSim &lt;- SpaDES.core::spades(castorInit)\n\n## we now have outputs\nSpaDES.core::outputs(castorSim)\n\n\n\n\n          objectName\n1      harvestReport\n2 growingStockReport\n                                                                                                file\n1      /home/runner/tutos/castorExample/R/scenarios/comparison_stsm/outputs/harvestReport_year20.rds\n2 /home/runner/tutos/castorExample/R/scenarios/comparison_stsm/outputs/growingStockReport_year20.rds\n      fun package saveTime saved arguments\n1 saveRDS    base       20  TRUE        NA\n2 saveRDS    base       20  TRUE        NA\n\n\ncompleted(castorSim) shows the chaining of events that was produced and run by spades(). The sequence of steps in the workflow therefore arises from each module’s events and their scheduling, rather than being explicitly imposed by the user.\n\n\nCode\nSpaDES.core::completed(castorSim)\n\n\n    eventTime         moduleName          eventType eventPriority\n        &lt;num&gt;             &lt;char&gt;             &lt;char&gt;         &lt;num&gt;\n 1:         0         checkpoint               init             0\n 2:         0               save               init             0\n 3:         0           progress               init             0\n 4:         0               load               init             0\n 5:         0         dataCastor               init             1\n 6:         0 growingStockCastor               init             1\n 7:         0     blockingCastor               init             1\n 8:         0     forestryCastor               init             1\n....\n\n\nWe suggest omitting the blockingCastor module in setupProject() and rerunning the workflow again to see how spades is capable of re-generating a new workflow with little effort from the user.\n\n\nCode\nmodules &lt;- c(\"dataCastor\", \n             \"growingStockCastor\", \n             \"forestryCastor\")\n\nout &lt;- setupProject(\n  paths = list(\"inputPath\" = \"modules/forestryCastor/inputs\",\n               \"outputPath\" = \"/R/scenarios/comparison_stsm/outputs\",\n               \"modulePath\" = \"modules/\",\n               \"cachePath\" = \"modules/forestryCastor\",\n               \"projectPath\" = \"~/tutos/castorExample/\"),\n  modules = modules,\n  functions = \"bcgov/castor@main/R/functions/R_Postgres.R\",\n  ## install and load\n  require = \"dplyr\",\n  ## install but don't load these:\n  packages = c(\n    \"DBI\", \n    \"keyring\",\n    \"rgdal\", \n    \"RPostgreSQL\", \n    \"sp\",\n    \"terra\"\n  ),\n  params = \"params.R\",\n  times = list(start = 0, end = 20),\n  outputs = {\n    data.frame(objectName = c(\"harvestReport\",\n                              \"growingStockReport\"))\n  },\n  scenario = {\n    data.table(name = \"stsm_base_case\",\n               description = paste(\"Priority queue = oldest first. Adjacency constraint\",\n                                   \"= None. Includes roads (mst) and blocks (pre).\",\n                                   \"Harvest flow = 147,300 m3/year in decade 1, 133,500\",\n                                   \"m3/year in decade 2, 132,300 m3/year in decades 3 to\",\n                                   \"14 and 135,400 m3/year in decades 15 to 25.\",\n                                   \"Minimum harvest age = 80 and minimum harvest volume = 150\"))\n  },\n  harvestFlow = {\n    rbindlist(list(data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 1,\n                                                 to = 1, \n                                                 by = 1),\n                                            1), \n                              flow = 1473000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 2,\n                                                 to = 2, \n                                                 by = 1),\n                                            1), \n                              flow = 1335000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 3,\n                                                 to = 14, \n                                                 by = 1),\n                                            1), \n                              flow = 1323000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 15,\n                                                 to = 25, \n                                                 by = 1),\n                                            1), \n                              flow = 1354000, \n                              partition_type = 'live')  \n    ))\n  },\n  Restart = TRUE\n)\n\n## initialize and run simulation in one go\ncastorSim2 &lt;- do.call(SpaDES.core::simInitAndSpades, out)"
  },
  {
    "objectID": "castorExample.html#footnotes",
    "href": "castorExample.html#footnotes",
    "title": "5  Castor workflow with setupProject",
    "section": "",
    "text": "SpaDES.project is currently being adapted to deal with modules nested in folders of GitHub repositories (instead of living in their own GitHub repositories). Hence, the code in this example is subject to changes in the near future.↩︎\nUsing the googledrive R package. See ?googledrive::drive_auth for more information.↩︎\nSee also Section 4.1.↩︎"
  }
]