[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Robust and nimble scientific workflows, using SpaDES",
    "section": "",
    "text": "Preface\nThis book is a work in progress. Please visit this again as chapters are being added and modified.\n\n\nAcknowledgements\nWe thank the various contributors, SpaDES developers and SpaDES users that continue to make the open-source ecosystem of SpaDES modules grow.\nWe also thank the Quarto team for their great work."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Under construction."
  },
  {
    "objectID": "SpaDESbasics.html",
    "href": "SpaDESbasics.html",
    "title": "SpaDES 101",
    "section": "",
    "text": "Under construction."
  },
  {
    "objectID": "NewModuleIntro.html#some-r-code-to-convert",
    "href": "NewModuleIntro.html#some-r-code-to-convert",
    "title": "1  Introduction to SpaDES Modules",
    "section": "1.1 Some R code to convert",
    "text": "1.1 Some R code to convert\nWe will start by thinking about metadata: What is metadata?\nWe can examine the following code chunk. First, we ask: what are the inputs and the outputs?\n\n\nCode\n# create some data\ny &lt;- x + rnorm(10)\n# fit a linear model\nout &lt;- lm(y ~ x)\n\n# plot the fit\nplot(out)\n\n\nThe inputs to this chunk are just one: the object x. This code will not work (i.e., it will cause an error) if x is not defined. The outputs are y and out. Both of these are created within this chunk.\nNext, what are the package dependencies?. We see that there are three functions: rnorm, lm and plot. We don’t know what packages they are in, so we can find out by typing them at the R prompt. At the bottom of the function, it says that the function rnorm is in the stats package. Fortunately for us, this is a default (“base”) package in R and it is always pre-loaded. So, nothing to do here.\n\n\nCode\n&gt; rnorm\nfunction (n, mean = 0, sd = 1) \n...\n&lt;environment: namespace:stats&gt;\n\n\nSo, our metadata are:\n\nInputs: x\nOutputs: y, out\nPackage dependencies: Base packages only\n\nWe will next put them into the correct places in the new SpaDES module."
  },
  {
    "objectID": "NewModuleIntro.html#create-a-module",
    "href": "NewModuleIntro.html#create-a-module",
    "title": "1  Introduction to SpaDES Modules",
    "section": "1.2 Create a module",
    "text": "1.2 Create a module\nWe use the SpaDES.core function newModule() to make a new module.\n\n\nCode\nSpaDES.core::newModule(name = \"My_linear_model\", path = \"tutos/NewModuleIntro\")\n\n\nThis will create a new folder with several files in it. See ?newModule for details. For now, run the above and open the My_linear_model.R script that it creates."
  },
  {
    "objectID": "NewModuleIntro.html#module-metadata",
    "href": "NewModuleIntro.html#module-metadata",
    "title": "1  Introduction to SpaDES Modules",
    "section": "1.3 Module metadata",
    "text": "1.3 Module metadata\nScroll down to inputObjects and expectsInputs(). We will declare x as an “input” by putting it there.\n\n\nCode\ninputObjects = bindrows(\n    expectsInput(objectName = \"y\", objectClass = \"numeric\", \n                 desc = \"The inputs for the linear model\", sourceURL = NA)\n  )\n\n\nNext, scroll down to outputObjects and createsOutput(). We will declare y and out as “outputs” by putting them there. Don’t forget the comma at the end of each createsOutput() as each is an argument to bindrows.\n\n\nCode\noutputObjects = bindrows(\n    createsOutput(objectName = \"x\", objectClass = \"numeric\", \n                  desc = \"The randomly created varible that is used as a response variable\"),\n    createsOutput(objectName = \"out\", objectClass = \"lm\", \n                  desc = \"A linear model object from the equation (x ~ y)\")\n  )"
  },
  {
    "objectID": "NewModuleIntro.html#add-code---the-init-event-function",
    "href": "NewModuleIntro.html#add-code---the-init-event-function",
    "title": "1  Introduction to SpaDES Modules",
    "section": "1.4 Add code - the Init event function",
    "text": "1.4 Add code - the Init event function\nFirst, we move the first two lines of the previous code into a function. We will choose the Init function. We will discuss why bellow.\n\n\nCode\nInit &lt;- function(sim) {\n  y &lt;- x + rnorm(10)\n  out &lt;- lm(y ~ x)\n  return(invisible(sim))\n}\n\n\n\n1.4.1 Sharing inputs and outputs\nYou may have noticed that the Init function template defines a function with a sim argument. This is an object we haven’t learned about yet; we will just think of it as a list where we can put objects we want to share with other modules or “just keep them for later”, such as our inputs and outputs.\nTo share these objects, we assign them to the sim list using the normal R notation &lt;-. We have to make this modification 5 times for every instance of our inputs and outputs.\n\n\nCode\nInit &lt;- function(sim) {\n  sim$y &lt;- sim$x + rnorm(10)\n  sim$out &lt;- lm(sim$y ~ sim$x)\n  return(invisible(sim))\n}\n\n\nNow we have a module that creates two objects, y and out and puts them inside sim. This all happens in the function called Init \nNext: the plot(out)."
  },
  {
    "objectID": "NewModuleIntro.html#events",
    "href": "NewModuleIntro.html#events",
    "title": "1  Introduction to SpaDES Modules",
    "section": "1.5 Events",
    "text": "1.5 Events\nWe can look at our 3 lines of example and think, “this is 2 steps: step 1 fit the model and step 2 plots it”. Of course, you could divide this up in several ways (or not at all), but we will go with this for now.\nWe can call the 2 steps events and imagine we could run them in sequence… first, lets put the plotting step in a function. We will choose the plotFun function. We will also add the sim$ because the out will come from another step and is in the sim “list”.\n\n\nCode\nplotFun &lt;- function(sim) {\n  plot(sim$out)\n  return(invisible(sim))\n}\n\n\nThe template already has some default code that actually puts the events in an order without us needing to do anything. It also has a parameter that determines whether the plot will happen or not (.plots). We will just accept the defaults for now."
  },
  {
    "objectID": "NewModuleIntro.html#default-values",
    "href": "NewModuleIntro.html#default-values",
    "title": "1  Introduction to SpaDES Modules",
    "section": "1.6 Default Values",
    "text": "1.6 Default Values\nRecall, we don’t have a value for x. This means that if you run the following, you will get an error:\n\n\nCode\nSpaDES.core::simInitAndSpades(modules = \"My_linear_model\", paths = list(modulePath = \"tutos/NewModuleIntro\"))\n\n\nJust like functions in R, we can supply default values for our inputs. We put these in a function at the bottom called .inputObjects.\nCopy this to the module, replacing the contents of the template .inputObjects function.\n\n\nCode\n.inputObjects &lt;- function(sim) {\n  if (!suppliedElsewhere(\"x\", sim))\n    sim$x &lt;- rnorm(10, mean = 20, sd = 2)\n  return(invisible(sim))\n}\n\n\n!suppliedElsewhere(\"x\", sim) will check if x is in sim and if not, will run the subsequent code lines (see ?suppliedElsewhere)."
  },
  {
    "objectID": "NewModuleIntro.html#run-the-new-module",
    "href": "NewModuleIntro.html#run-the-new-module",
    "title": "1  Introduction to SpaDES Modules",
    "section": "1.7 Run the new module",
    "text": "1.7 Run the new module\nNow, we have inputs and outputs defined, our code has been places in 2 spots (events), and we have default value for x.\n\n\nCode\nSpaDES.core::simInitAndSpades(modules = \"My_linear_model\", paths = list(modulePath = \"tutos/NewModuleIntro\"))\n\n\nWe now have a SpaDES module that has metadata, generates random starting data (if the user doesn’t supply an alternative), fits a linear model, outputs that model, and plots the fit."
  },
  {
    "objectID": "NewModuleIntro.html#questions",
    "href": "NewModuleIntro.html#questions",
    "title": "1  Introduction to SpaDES Modules",
    "section": "1.8 Questions",
    "text": "1.8 Questions\n\nWhat are some things we “gained” from putting our simple 3 lines of code into a module?\n\nWe can turn off plotting easily. Set .plotInitialTime = NA in the simInitAndSpades call.\n\nWhat are some things we “lost”?\n\nMore complicated. (overkill for these 3 lines?)\n\nWhat if we used an R package that wasn’t in the base packages list?\n\nSee ?defineModule for all the metadata items. Specifically, see reqdPkgs.\n\nWhat is the sim? See ?'.simList-class'"
  },
  {
    "objectID": "NewModuleIntro.html#see-also",
    "href": "NewModuleIntro.html#see-also",
    "title": "1  Introduction to SpaDES Modules",
    "section": "1.9 See also",
    "text": "1.9 See also\n?expectsInput, ?createsOutput, ?simInitAndSpades, ?newModule"
  },
  {
    "objectID": "ModulesAndEvents.html#modules",
    "href": "ModulesAndEvents.html#modules",
    "title": "2  Modules, Events and Functions",
    "section": "2.1 Modules",
    "text": "2.1 Modules\nModules include the following elements:\n\na function call to defineModule that defines the metadata (mandatory)\na function definition for doEvent.moduleName (mandatory)\n\nThere are many optional pieces too. The default template produces many of these optional pieces, which means it is “noisy”. This also means we can ignore most of it for now.\nOptional pieces include:\n\nother functions in the R folder or the main moduleName.R file\na documentation file (moduleName.rmd)\n\nThese are all contained within a file structure like this, with other optional files:\n/moduleRepository\n  |_ moduleName/\n      |_ R/                     # contains additional/optional .R (helper) files\n      |_ data/                  # directory for all included data\n          |_ CHECKSUMS.txt      # contains checksums for data files\n      |_ tests/                 # contains (optional) unit tests for module code\n      |_ citation.bib           # bibtex citation for the module\n      |_ LICENSE.txt            # describes module's legal usage\n      |_ moduleName.R           # module code file (incl. metadata)\n      |_ moduleName.Rmd         # documentation, usage info, etc.\nTo make a new module, see: Chapter 1."
  },
  {
    "objectID": "ModulesAndEvents.html#events",
    "href": "ModulesAndEvents.html#events",
    "title": "2  Modules, Events and Functions",
    "section": "2.2 Events",
    "text": "2.2 Events\nEvents are named chunks of code that can be scheduled to be run once or many times. These are scheduled with scheduleEvent(). There are several commonly occurring module types that can be grouped based on the events that they contain (see Section 2.4).\nTo see how to schedule events, see: Chapter 3."
  },
  {
    "objectID": "ModulesAndEvents.html#functions",
    "href": "ModulesAndEvents.html#functions",
    "title": "2  Modules, Events and Functions",
    "section": "2.3 Functions",
    "text": "2.3 Functions\nEssentially, everything in R is or uses functions. Modules define functions (doEvent.*moduleName*), events call specific functions (we some times call these “event functions”), and functions can be defined within modules, R packages, or user code.\n\n2.3.1 Rerun-tolerant functions\nIn re-usable workflows, functions become particularly effective if they are rerun-tolerant, see (tip-Rerun?) (we use tolerant in part to reflect the fact that the computer tolerates it but also the human because they don’t have to wait).\n\n\n\n\n\n\nTip\n\n\n\nFunctions are rerun-tolerant if they\n\nare rerun-efficient, meaning the first time they run they “do” something, but the second and subsequent times, they give the same output as the first time, but they skip the “doing” part\n\n\noptionally the efficiency can be by memory caching (“memoising”) and/or more persistent disk caching.\n\n\nand are rerun-robust, meaning they can be run error-free and with sensible or identical outputs (if inputs are the same) using any person’s computer.\n\n\n\nTo achieve these qualities, functions must use some sort of caching (i.e., evaluate the call and skip the content of the function if the call is deemed identical to a previous version of the call), and they must address any computer or operating system issues (such as paths, package dependencies etc.).\nBase R has some functions that are like this and some that are not. For example library is rerun-tolerant because it does something the first time, which may be slow, and subsequent times in the same session it is fast (memory efficient, but not disk efficient)\nTwo key functions help achieve these points, ?reproducible::Cache and ?reproducible::prepInputs\n\n\n2.3.2 Cache()\nCache() is a function that can be wrapped around other functions that turns that function into a rerun-tolerant function. reproducible::Cache has several important modifications that work for some objects that don’t cache well using “normal” caching, such as terra objects that are actually pointers to locations on disk rather than normal R objects.\nThe following code will result in d being the same vector as b, and it will be returned quickly.\n\n\nCode\nlibrary(reproducible)\n\na &lt;- rnorm(1e7)\nb &lt;- rnorm(1e7) |&gt; Cache()\nd &lt;- rnorm(1e7) |&gt; Cache()\n\n\nSee ?reproducible::Cache\n\n\n2.3.3 prepInputs()\nprepInputs() is a workhorse function that helps users point to cloud or local datasets: ?reproducible::prepInputs.\nIn this example, we point to a url only and prepInputs downloads it, does checksumming, unzips it and loads it into R using the default terra::vect because it is a shp file after the unzipping.\n\n\nCode\necozoneOfCanada &lt;- reproducible::prepInputs(\n  url = \"http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip\")\n\n\nFor more information ?reproducible::prepInputs"
  },
  {
    "objectID": "ModulesAndEvents.html#sec-moduletypes",
    "href": "ModulesAndEvents.html#sec-moduletypes",
    "title": "2  Modules, Events and Functions",
    "section": "2.4 Module types",
    "text": "2.4 Module types\nEven though all modules are built with the same structures (events & functions), for convenience, we can categorize different types of modules in different ways.\nFor example, modules can be categorized by:\n\n2.4.1 Static\nStatic modules can be defined as modules that “run once”. This means that they may have only one event. Or a sequence of events that occur one after the other with no rescheduling.\nThese could include: - Data preparation modules; - one (maybe just the “init” event) or few events and their primary goal is to get and deal with data; - GIS modules that do a number of GIS operations to get data into the necessary formats; - Data Visualization modules that specialize in creating a set of visuals from a known set of inputs.\n\n\n2.4.2 Dynamic\nDynamic modules are modules that have events that recur. There are at least 2 types of such models: those that have cyclic dependencies, i.e., its outputs are also its inputs (possibly with other modules in between) and those that do not.\n\nlandscape simulation modules (e.g., wildfire, vegetation change)\nwildlife population modules with Markov dependency (e.g., population matrix models)\nwildlife population modules without Markov-dependency (e.g., population models that only depend on habitat covariates)\nData Visualization modules that get used e.g., annually after other modules.\n\nIn Barros et al. (2023) we classified modules with respect to what the modules try to accomplish:\n\n“data/calibration modules” prepare model inputs and parameters\n“prediction/simulation modules” generate predictions using either static or dynamic mechanisms\n“validation modules” evaluate predictions against independent data.\n\nThere are no strict rules to classify a SpaDES module, just as there are no strict rule classify an R script."
  },
  {
    "objectID": "ModulesAndEvents.html#see-also",
    "href": "ModulesAndEvents.html#see-also",
    "title": "2  Modules, Events and Functions",
    "section": "2.5 See also",
    "text": "2.5 See also\nSee also: Chapter 3, ?scheduleEvent, ?P, ?time, ?start, ?end"
  },
  {
    "objectID": "ModulesAndEvents.html#more-learning-on-this-subject",
    "href": "ModulesAndEvents.html#more-learning-on-this-subject",
    "title": "2  Modules, Events and Functions",
    "section": "2.6 More learning on this subject",
    "text": "2.6 More learning on this subject\nMy First Module\nCreating a seed dispersal module\n\n\n\n\nBarros, Ceres, Yong Luo, Alex M. Chubaty, Ian M. S. Eddy, Tatiane Micheletti, Céline Boisvenue, David W. Andison, Steven G. Cumming, and Eliot J. B. McIntire. 2023. “Empowering Ecological Modellers with a PERFICT Workflow: Seamlessly Linking Data, Parameterisation, Prediction, Validation and Visualisation.” Methods in Ecology and Evolution 14 (1): 173–88. https://doi.org/10.1111/2041-210X.14034."
  },
  {
    "objectID": "Scheduling.html#convert-to-a-module",
    "href": "Scheduling.html#convert-to-a-module",
    "title": "3  Scheduling events",
    "section": "3.1 Convert to a module",
    "text": "3.1 Convert to a module\nIn the above code, there are 4 sections. These will each be copied into the SpaDES module below, in their respective sections. We have added 1 new section, called “Prediction”.\n\n\nCode\nSpaDES.core::newModule(name = \"scheduling\", path = \"tutos/scheduling\")\n\n\nOpen the module file, which will be printed in the console. Scroll down to the Init function and copy the Init, the .inputObjects, the Plot parts in the code above into the new module, as we did in Chapter 1.\nWe must make the same decisions about “local objects” (objects that are OK not to be kept for later) and about “global objects” (those that we want to keep). These global objects get put into sim. Your new module should have these 3 new sections/functions:\n\n\nCode\nInit &lt;- function(sim) {\n  y &lt;- sim$x + rnorm(10)\n  # fit a linear model\n  sim$out &lt;- lm(y ~ sim$x)\n  sim$pred &lt;- list()\n}\n\nplotFun &lt;- function(sim) {\n  sim$predictions &lt;- data.frame(year = rep(sim$years, each = 10), prediction = unlist(sim$pred))\n  # plot the predictions\n  sim$gg &lt;- ggplot(sim$predictions, aes(x = year, y = prediction, colour = year)) + geom_point() + geom_smooth()\n  print(sim$gg)\n}\n\n.inputObjects &lt;- function(sim) {\n  sim$x &lt;- rnorm(10)\n}"
  },
  {
    "objectID": "Scheduling.html#new-event-function-prediction",
    "href": "Scheduling.html#new-event-function-prediction",
    "title": "3  Scheduling events",
    "section": "3.2 New Event Function – Prediction",
    "text": "3.2 New Event Function – Prediction\nThe new part is the for loop. This part takes new covariates (new values for y), emulating “predicted” covariates, derives a newly predicted x, and we then keep these predicted x values each year.\nWe’ll use scheduleEvent() below to do this iteration. For now, copy the Prediction part into a new function:\n\n\nCode\nPrediction &lt;- function(sim) {\n  startYear &lt;- 2023\n  sim$years &lt;- startYear:(startYear + 10) + 1\n  for (year in sim$years - startYear) {\n    sim$pred[[year]] &lt;- predict(sim$out, newdata = data.frame(y = rnorm(10) + year))\n  }\n  return(invisible(sim))\n}"
  },
  {
    "objectID": "Scheduling.html#scheduling",
    "href": "Scheduling.html#scheduling",
    "title": "3  Scheduling events",
    "section": "3.3 Scheduling",
    "text": "3.3 Scheduling\nNow we need to tell SpaDES when to do and when to iterate each of the steps or “events”. The Init we do once, at the start. The plotFn we do once, but this time it is at the “end”. The .inputObjects always only happens once and “before the start” (Init) – it is scheduled automatically so nothing to do here. The last part (i.e., the prediction event) must happen 10 times, and it must start after Init and before the plotFn.\n\n3.3.1 doEvent\nThere is a special function in a SpaDES module called doEvent(). SpaDES calls this function once, passing the argument event = \"init\". That means that R will enter into this function only once and run only the init part, unless we specifically tell it to do more, using the scheduleEvent function.\nWe place this function anywhere we want inside doEvent, in general. In this example, we will place it in a few places.\n\n3.3.1.1 In the init event\nWe look at the init event (code inside event = \"init\") and we see 2 scheduleEvent calls that come with the template. We will use those to learn. In each “event”, we often see one part that “does something” and another part that “schedules something”.\nIn the default template, we “do” the Init function and we schedule plot and save. We can delete the save event, as we won’t do that here. But we will replace it with “schedule prediction”.\nSee ?start, ?scheduleEventhttps://rdrr.io/cran/SpaDES.core/man/scheduleEvent.html, ?P\n\n\nCode\nsim &lt;- Init(sim)\n\n# schedule future event(s)\nsim &lt;- scheduleEvent(sim, P(sim)$.plotInitialTime, \"scheduling\", \"plot\")\n# sim &lt;- scheduleEvent(sim, P(sim)$.saveInitialTime, \"scheduling\", \"save\")\n\n# here we create a new event type == \"predictions\" and we schedule it for `start(sim)`\nsim &lt;- scheduleEvent(sim, start(sim), \"scheduling\", \"predictions\") \n\n\nCopy the above code chunk to the init section so that it looks like this:\n\n\nCode\nswitch(\n  eventType,\n  init = {\n    sim &lt;- Init(sim)\n    \n    # schedule future event(s)\n    sim &lt;- scheduleEvent(sim, P(sim)$.plotInitialTime, \"scheduling\", \"plot\")\n    \n    # here we create a new event type == \"predictions\" and we schedule it for `start(sim)`\n    sim &lt;- scheduleEvent(sim, start(sim), \"scheduling\", \"predictions\") \n  },\n  ...\n)\n\n\n\n\n\n3.3.2 The new event\nWe add code to make a new event, called \"predictions\" (the name must match what we wrote in the scheduleEvent above). In this event, we “do” the prediction, then we schedule the next prediction at “time plus 1”\nSee ?time.\n\n\nCode\nswitch(\n  eventType,\n  init = {...},\n  predictions = {\n    # do the Prediction\n    sim &lt;- Prediction(sim)\n    \n    # schedule the next Prediction\n    sim &lt;- scheduleEvent(sim, time(sim) + 1, \"scheduling\", \"predictions\") \n  },\n  ...\n)\n\n\n\n\n3.3.3 Double check existing events\nIf we ran the above changes, we would see an error because plotFn is, by default, scheduled to run at the time that is specified by .plotInitialTime, which by default is start(sim). We have no data yet at that time. So, we have to schedule plotFn to run at end(sim):\n\n\nCode\nscheduleEvent(sim, end(sim), \"scheduling\", \"plot\")\n\n\n\n\n3.3.4 Update module metadata\nLike in Chapter 1, we have to update the module metadata… what the inputs, outputs, parameters are. SpaDES will not error if the metadata are not correct, but it will try to point out the problems.\nHere’s an example:\n\n\nCode\ncreatesOutput(objectName = \"predictions\", objectClass = \"data.frame\", \n              desc = \"Table of predictions and years\")"
  },
  {
    "objectID": "Scheduling.html#run",
    "href": "Scheduling.html#run",
    "title": "3  Scheduling events",
    "section": "3.4 Run",
    "text": "3.4 Run\nThe resulting module can now be run.\n\n\nCode\nSpaDES.core::simInitAndSpades(modules = \"scheduling\", paths = list(modulePath = \"tutos/scheduling\"))\n\n\nA complete version of this new module can be found at scheduling.R. You can copy this over top of the new module that you created here, i.e., keep the same folder structure."
  },
  {
    "objectID": "Scheduling.html#questions",
    "href": "Scheduling.html#questions",
    "title": "3  Scheduling events",
    "section": "3.5 Questions",
    "text": "3.5 Questions\n\nhow are some ways that scheduleEvent is different from a “loop”?\n\nWe can change the “step” length between events.\nWe can interweave events, e.g., a fire event then a tree growth event\n\n\n\n\nWhen is a loop better than scheduling?\n\nLoops are much faster than scheduling.\nBut really, avoid loops in R if you can help it\n\n\n\n\nChances are that the first versions of this module didn’t work. How do you fix it?\n\nLearn how to debug in R and SpaDES"
  },
  {
    "objectID": "Scheduling.html#see-also",
    "href": "Scheduling.html#see-also",
    "title": "3  Scheduling events",
    "section": "3.6 See also",
    "text": "3.6 See also\n?scheduleEvent, ?P, ?time, ?start, ?end"
  },
  {
    "objectID": "Scheduling.html#more-learning-on-this-subject",
    "href": "Scheduling.html#more-learning-on-this-subject",
    "title": "3  Scheduling events",
    "section": "3.7 More learning on this subject",
    "text": "3.7 More learning on this subject\nMy First Module\nCreating a seed dispersal module"
  },
  {
    "objectID": "simList.html#where-does-simlist-come-from",
    "href": "simList.html#where-does-simlist-come-from",
    "title": "4  The simList - What is it?",
    "section": "4.1 Where does simList come from?",
    "text": "4.1 Where does simList come from?\nThere are 2 main ways in SpaDES.core to create a simList:\n\nusing simInit() creates a simList object.\nusing spades() , which returns a modified simList object."
  },
  {
    "objectID": "simList.html#how-can-we-specify-a-simlist",
    "href": "simList.html#how-can-we-specify-a-simlist",
    "title": "4  The simList - What is it?",
    "section": "4.2 How can we specify a simList?",
    "text": "4.2 How can we specify a simList?\nA simList object is simply a structured data type containing various elements.\nThe main components of a simList are:\n\nA list of modules used;\nThe event queue;\nA description of the data (object) dependencies."
  },
  {
    "objectID": "simList.html#how-spades-works-simlists",
    "href": "simList.html#how-spades-works-simlists",
    "title": "4  The simList - What is it?",
    "section": "4.3 How SpaDES works: simLists",
    "text": "4.3 How SpaDES works: simLists\nWe can examine the simList object structure in the usual R fashion by printing (showing) it, or by using str():\n\n\nCode\nemptySim &lt;- simInit()\nemptySim  # same as show(emptySim)\nstr(emptySim)\n\n\nNOTE: simLists are S4 objects, so we can use getSlots() and slotNames() to examine the object.\nSee also ?'.simList-class'"
  },
  {
    "objectID": "simList.html#accessing-the-parts-of-a-simlists",
    "href": "simList.html#accessing-the-parts-of-a-simlists",
    "title": "4  The simList - What is it?",
    "section": "4.4 Accessing the parts of a simLists",
    "text": "4.4 Accessing the parts of a simLists\n\n\n\nSetting:\n  options(\n    reproducible.cachePath = '/tmp/RtmpONKrSh/reproducible/cache'\n    spades.inputPath = '/tmp/RtmpONKrSh/SpaDES/inputs'\n    spades.outputPath = '/tmp/RtmpONKrSh/SpaDES/outputs'\n    spades.modulePath = '/tmp/RtmpONKrSh/SpaDES/modules'\n    spades.scratchPath = '/tmp/RtmpONKrSh/SpaDES/scratch'\n  )\n\n\nMay08 17:46:37 simInit Using setDTthreads(1). To change: 'options(spades.DTthreads = X)'.\n\n\nElpsed time for simInit: 0.02363276 secs\n\n\n\n\n\nslot\naccessor\n\n\n\n\nmodules\nmodules()\n\n\nparams\nparams()\n\n\nevents\nevents()\n\n\ncurrent\ncurrent()\n\n\ncompleted\ncompleted()\n\n\ndepends\ndepends()\n\n\nsimtimes\ntimes()\n\n\ninputs\ninputs()\n\n\noutputs\noutputs()\n\n\npaths\npaths()\n\n\n.envir\nenvir()\n\n\n.xData\nobjects()\n\n\n\n\n\n\n\n\n\n\n\n\nother_accessors\n\n\n\n\npackages()\n\n\nglobals()\n\n\nstart()\n\n\nend()\n\n\ntimeunit()\n\n\ntimeunits()\n\n\npaths()\n\n\ncachePath()\n\n\ninputPath()\n\n\noutputPath()\n\n\nmodulePath()"
  },
  {
    "objectID": "simList.html#model-specification",
    "href": "simList.html#model-specification",
    "title": "4  The simList - What is it?",
    "section": "4.5 Model specification",
    "text": "4.5 Model specification\nSimple examples (using demo modules) of simInit() and spades() calls.\n\nexamine simList structure before and after the spades() call\n\n\n4.5.1 Initiliaze an empty simList object\n\n\nCode\nemptySim &lt;- simInit()\n\n\n\n\nSetting:\n  options(\n    reproducible.cachePath = '/tmp/RtmpONKrSh/reproducible/cache'\n    spades.inputPath = '/tmp/RtmpONKrSh/SpaDES/inputs'\n    spades.outputPath = '/tmp/RtmpONKrSh/SpaDES/outputs'\n    spades.modulePath = '/tmp/RtmpONKrSh/SpaDES/modules'\n    spades.scratchPath = '/tmp/RtmpONKrSh/SpaDES/scratch'\n  )\n\n\nMay08 17:46:37 simInit Using setDTthreads(1). To change: 'options(spades.DTthreads = X)'.\n\n\nElpsed time for simInit: 0.01504898 secs\n\n\n\n\n4.5.2 Inspect the empty simList object\n\nWhat are the names of each of the slots in the simList?\nWhat do each of these slots contain? Hint: see ?.simList-class\n\n\n\nCode\nstr(emptySim)\nslotNames(emptySim)\ngetSlots('simList')\n?'.simList-class'\n\n\n\n\n4.5.3 Inspect the new simList object\nUse the simList accessor functions to determine the following:\n\nthe modules included in the simulation and their package dependencies;\nthe global parameter values used;\nthe module-specific parameter values used;\nthe simulation start and end times;\nthe timeunits used by the modules in the simulation;\nthe scheduled and completed event queues;\nthe objects (functions, data, etc.) used in the simulation;\nthe file paths used for simulation inputs and outputs.\n\n\n\nCode\n# list modules used in the simulation\nmodules(mySim)\n\n# list module dependencies and packages used\ndepends(mySim)\npackages(mySim)\n\n# list global and module-specific param values\nglobals(mySim)\nparams(mySim)\nP(mySim)       ## bonus: how do params() and P() differ?\n\n# list start and end times\ntimes(mySim)\nstart(mySim)\nend(mySim)\n\n# get the simulation and module timeunits\ntimeunit(mySim)\ntimeunits(mySim)\n\n# get the scheduled and completed event queues\nevents(mySim)\ncompleted(mySim)\n\n# list the objects (functions, data, etc.) stored in the simList\nobjects(mySim)\n\n# list the file paths used in the simulation\npaths(mySim)\ninputPath(mySim)\noutputPath(mySim)\n\n\n\n\n4.5.4 Run the simulation\n\n\nCode\ndev()\nmySimOut &lt;- Copy(mySim) ## make a deep copy of the simList\nmySimOut &lt;- spades(mySimOut)\n\n\n\n\n4.5.5 Compare the simList before and after\n\n\nCode\ntimes(mySim)\ntimes(mySimOut)\n\nobjects(mySim)\nobjects(mySimOut)"
  },
  {
    "objectID": "simList.html#see-also",
    "href": "simList.html#see-also",
    "title": "4  The simList - What is it?",
    "section": "4.6 See also",
    "text": "4.6 See also\n?.simList-class ?simInit ?spades"
  },
  {
    "objectID": "ModuleInputs.html#how-to-supply-inputs",
    "href": "ModuleInputs.html#how-to-supply-inputs",
    "title": "5  Module Inputs",
    "section": "5.1 How to supply Inputs",
    "text": "5.1 How to supply Inputs\nThere are several ways to get objects into the simList:\n\nUser passes during simInit:\n\nusing the objects argument (if it is an object);\nusing the inputs argument (if it is from disk);\n\nDeveloper creates defaults and specifies them in .inputObjects;\nA different module creates them prior to the running of this module.\n\nUltimately, it is the last of these that is the power of SpaDES. i.e., modularity.\n\n5.1.1 During simInit\nA user can directly pass objects into the simInit and these will be put into the simList\n\n\nCode\na &lt;- 1\nsim &lt;- SpaDES.core::simInit(objects = list(a = a))\n\n\nor do pass them via an .rds file\n\n\nCode\nb &lt;- 1\ntf &lt;- tempfile(fileext = \".rds\")\nsaveRDS(b, file = tf)\nsim &lt;- SpaDES.core::simInit(inputs = data.frame(object = \"b\", file = tf))\n# now it is \"sim$b\"\n\n\nSee ?SpaDES.core::simInit.\n\n\n5.1.2 .inputObjects\nFor every Input that is specified in the metadata, the module developer has the option of specifying a default. In R, functions can be given defaults when they are defined like this:\n\n\nCode\nrnormMean5 &lt;- function(n = 1) { # the n = 1 is the default value\n  rnorm(n = n, mean = 5)\n}\nrnormMean5() # can be run without any arguments\n\n\nThis works for only the simplest cases. In the case of a module, objects can be arbitrarily complicated and so this approach will not be suitable.\nInstead, there is a function that is called every time a module is initialized (i.e. by simInit()) where a developer can put anything they want to specify as defaults. It is generally most useful to use if (!SpaDES.core::suppliedElsewhere(\"obj\", sim)) i.e., if the object isn’t in sim, then give it a value.\n\n\nCode\n.inputObjects &lt;- function(sim) {\n\n  if (!suppliedElsewhere(\"y\", sim)) {\n    sim$y &lt;- rnorm(100)\n  }\n\n  return(sim)\n}\n\n\n\n5.1.2.1 Advanced .inputObjects example\nIn the Biomass_core module (this is an implementation of the LANDIS-II Biomass Succession Extension v3.2), there are many Inputs as defined in the metadata. The module needs each one of these to work.\nThe developers have created a .inputObjects function that will fill in these Inputs with defaults if the user hasn’t supplied them (using !SpaDES.core::suppliedElsewhere()).\nWe will look at a few examples in this module: Biomass_core::.inputObjects.\nFirst, an object called studyArea. The developer tests whether it exists and creates an error if it does not exist.\nSecond, some GIS tests that evaluate whether 2 objects are in the same CRS (i.e., they need to be the same projection, etc., for this module to work)\nThird, if an object is missing, it may make sense to fill in the details with parameters from the Internet.\n\n\n\n5.1.3 From another module\nWe will leave this section for the ?sec-manymodules chapter, where we are work with multiple modules."
  },
  {
    "objectID": "ModuleInputs.html#questions",
    "href": "ModuleInputs.html#questions",
    "title": "5  Module Inputs",
    "section": "5.2 Questions",
    "text": "5.2 Questions\n\nIn .inputObjects, why don’t we just write if (!is.null(sim$y))? See ?SpaDES.core::suppliedElsewhere\n\nIt turns out that other modules may create this object “after” this module is run, and this test will fail."
  },
  {
    "objectID": "ModuleInputs.html#see-also",
    "href": "ModuleInputs.html#see-also",
    "title": "5  Module Inputs",
    "section": "5.3 See also",
    "text": "5.3 See also\n?SpaDES.core::suppliedElsewhere\n?SpaDES.core::expectsInputs\n?SpaDES.core::simInit"
  },
  {
    "objectID": "SpaDESworkflows.html",
    "href": "SpaDESworkflows.html",
    "title": "SpaDES workflows and projects",
    "section": "",
    "text": "One of the advantages of SpaDES is that workflows arise from the combinations of modules (and of their events) being put together by a user. Because SpaDES automatically chains, schedules and executes events within and across modules, if the group of modules changes, so do the workflow steps being executed.\nWhen module developers make sure modules are able to obtain defaults values for all their inputs and when many modules have inputs and outputs in common, recombining modules to creating new workflows can happen at relatively little cost for a user.\nIn this section, we will cover how to chain together many modules and how to create entire project workflows with SpaDES.project."
  },
  {
    "objectID": "multipleModules.html",
    "href": "multipleModules.html",
    "title": "6  Multiple Modules",
    "section": "",
    "text": "Under construction."
  },
  {
    "objectID": "realexamples.html",
    "href": "realexamples.html",
    "title": "“Real-world” examples of SpaDES workflows",
    "section": "",
    "text": "This section will take you through several “real-world” examples that use SpaDES to build and execute a workflow. By “real-world” we mean workflows that use models that have been/are used in research or application.\nBecause we will not explain each model or the SpaDES modules in detail, we encourage learning more about these models from the sources noted in the chapters.\nIn this section we assume that readers are familiar with SpaDES, namely creating and using SpaDES modules. If not, we encourage going through the chapters in SpaDES 101."
  },
  {
    "objectID": "castorExample.html#workflow-setup",
    "href": "castorExample.html#workflow-setup",
    "title": "7  Castor workflow with setupProject",
    "section": "7.1 Workflow setup",
    "text": "7.1 Workflow setup\nSpaDES.project functions expect SpaDES modules to either exist locally, or at root level of separate repositories. This is not the case with Castor modules, which are in a nested folder (i.e. a folder in a folder tree) of a single GitHub repository.\nSpaDES.project will eventually be able to deal with this1, but for now we work around this issue by using a custom function called getCastorModulesAndDB. This function will also download the demo SQLite database from Google Drive2. You’ll be prompted to authorise this operation and a browser window will open for this. Make sure you give tidyverse read/write access to your files:\n\n\n\n\n\nFigure 7.1: ?(caption)\n\n\n\n\nAfter the “workaround” setupProject does all the heavy-lifting of setting up the workflow, namely installing all package dependencies listed in the several modules and in setupProject(..., packages), creating all the necessary folders, sourcing additional files and creating parameter, inputs and outputs lists – see ?setupProject.\n\n\nCode\n## install/load necessary packages\nrepos &lt;- c(\"predictiveecology.r-universe.dev\", getOption(\"repos\"))\ninstall.packages(c(\"remotes\", \"reproducible\", \"googledrive\"), repos = repos)\nremotes::install_github(\"PredictiveEcology/SpaDES.project@transition\")   ## to deal with modules in nested GH folders.\nlibrary(SpaDES.project)\n\n## get Castor modules and functions\nsetupFunctions(paths = list(\"projectPath\" = \"~/\"),\n               functions = c(\"PredictiveEcology/PredictiveEcology.org@training-book/tutos/castorExample/getCastorModulesAndDB.R\",\n                             \"PredictiveEcology/PredictiveEcology.org@training-book/tutos/castorExample/params.R\"),\n               overwrite = TRUE)\noutMod &lt;- getCastorModulesAndDB(paths = list(\"modulePath\" = \"~/tutos/castorExample/modules/\",\n                                             \"projectPath\" = \"~/tutos/castorExample\"),\n                                modules = c(\"dataCastor\", \n                                            \"growingStockCastor\", \n                                            \"forestryCastor\", \n                                            \"blockingCastor\"),\n                                dbURL = \"https://drive.google.com/file/d/1-2POunzC7aFbkKK5LeBJNsFYMBBY8dNx/view?usp=sharing\",\n                                dbPath = \"~/tutos/castorExample/R/scenarios/comparison_stsm\")\n\n## set up the workflow paths, dependencies and modules\n## as well as simulation parameters, (some) inputs and outputs\nout &lt;- setupProject(\n  paths = list(\"inputPath\" = \"modules/forestryCastor/inputs\",\n               \"outputPath\" = \"R/scenarios/comparison_stsm/outputs\",\n               \"modulePath\" = \"modules/\",\n               \"cachePath\" = \"modules/forestryCastor\",\n               \"projectPath\" = \"~/tutos/castorExample\"),\n  modules = names(outMod$modules),\n  functions = \"bcgov/castor@main/R/functions/R_Postgres.R\",\n  ## install and load\n  require = \"dplyr\",\n  ## install but don't load these:\n  packages = c(\n    \"DBI\", \n    \"DiagrammeR\",\n    \"keyring\",\n    \"rgdal\", \n    \"RPostgreSQL\", \n    \"sp\",\n    \"terra\"\n  ),\n  params = \"params.R\",\n  times = list(start = 0, end = 20),\n  outputs = {\n    data.frame(objectName = c(\"harvestReport\",\n                              \"growingStockReport\"))\n  },\n  scenario = {\n    data.table(name = \"stsm_base_case\",\n               description = paste(\"Priority queue = oldest first. Adjacency constraint\",\n                                   \"= None. Includes roads (mst) and blocks (pre).\",\n                                   \"Harvest flow = 147,300 m3/year in decade 1, 133,500\",\n                                   \"m3/year in decade 2, 132,300 m3/year in decades 3 to\",\n                                   \"14 and 135,400 m3/year in decades 15 to 25.\",\n                                   \"Minimum harvest age = 80 and minimum harvest volume = 150\"))\n  },\n  harvestFlow = {\n    rbindlist(list(data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 1,\n                                                 to = 1, \n                                                 by = 1),\n                                            1), \n                              flow = 1473000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 2,\n                                                 to = 2, \n                                                 by = 1),\n                                            1), \n                              flow = 1335000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 3,\n                                                 to = 14, \n                                                 by = 1),\n                                            1), \n                              flow = 1323000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 15,\n                                                 to = 25, \n                                                 by = 1),\n                                            1), \n                              flow = 1354000, \n                              partition_type = 'live')  \n    ))\n  },\n  Restart = TRUE\n)"
  },
  {
    "objectID": "castorExample.html#initialise-the-model-and-inspect-simlist",
    "href": "castorExample.html#initialise-the-model-and-inspect-simlist",
    "title": "7  Castor workflow with setupProject",
    "section": "7.2 Initialise the model and inspect simList",
    "text": "7.2 Initialise the model and inspect simList\nsetupProject() returns a names list containing values that can be passed as argument to simInit()3.\nWe use do.call() to pass the whole list of arguments to simInit.\n\n\nCode\n## initialize simulation\ncastorInit &lt;- do.call(SpaDES.core::simInit, out)\n\n\nAnother (more verbose) option would to call simInit directly:\n\n\nCode\ncastorInit &lt;- SpaDES.core::simInit(\n  times = out$times,\n  params = out$params, \n  modules = out$modules, \n  objects = list(scenario = out$scenario, \n                 harvestFlow = out$harvestFlow)\n)\n\n\nUse the following functions to access workflow/model properties. events(), for instance will output the scheduled events, which at this point are only the init events of each module as you can see in the output below.\n\n\nCode\n## inspect the `simList`\nSpaDES.core::params(castorInit) \nSpaDES.core::inputs(castorInit)\nSpaDES.core::outputs(castorInit)\nSpaDES.core::times(castorInit) \n\n## scheduled events\nSpaDES.core::events(castorInit) \n\n\n\n\n   eventTime         moduleName eventType eventPriority\n       &lt;num&gt;             &lt;char&gt;    &lt;char&gt;         &lt;num&gt;\n1:         0         checkpoint      init             0\n2:         0               save      init             0\n3:         0           progress      init             0\n4:         0               load      init             0\n5:         0         dataCastor      init             1\n6:         0 growingStockCastor      init             1\n7:         0     blockingCastor      init             1\n8:         0     forestryCastor      init             1"
  },
  {
    "objectID": "castorExample.html#visualize-the-workflow",
    "href": "castorExample.html#visualize-the-workflow",
    "title": "7  Castor workflow with setupProject",
    "section": "7.3 Visualize the workflow",
    "text": "7.3 Visualize the workflow\nmoduleDiagram() and objectDiagram() are great to visualise how each module interacts with the other. Recall that these interactions arise from object “exchanges” between modules, which are deduced by simInit() from module metadata (Figure 7.3) – i.e., if a module’s inputs are another’s outputs, then the first module will follow the second.\n\n\nCode\nSpaDES.core::moduleDiagram(castorInit)\nSpaDES.core::objectDiagram(castorInit)\n\n\n\n\n\n\n\nFigure 7.2: Diagram of module connections.\n\n\n\n\n\n\n\n\n\nFigure 7.3: Diagram of module inter-dependencies with object names."
  },
  {
    "objectID": "castorExample.html#run-simulation",
    "href": "castorExample.html#run-simulation",
    "title": "7  Castor workflow with setupProject",
    "section": "7.4 Run simulation",
    "text": "7.4 Run simulation\nspades() runs the simulation, beginning with the execution of the init events. Notice how the result of outputs() differs from previously.\n\n\nCode\ncastorSim &lt;- SpaDES.core::spades(castorInit)\n\n## we now have outputs\nSpaDES.core::outputs(castorSim)\n\n\n\n\n          objectName\n1      harvestReport\n2 growingStockReport\n                                                                                                file\n1      /home/runner/tutos/castorExample/R/scenarios/comparison_stsm/outputs/harvestReport_year20.rds\n2 /home/runner/tutos/castorExample/R/scenarios/comparison_stsm/outputs/growingStockReport_year20.rds\n      fun package saveTime saved arguments\n1 saveRDS    base       20  TRUE        NA\n2 saveRDS    base       20  TRUE        NA\n\n\ncompleted(castorSim) shows the chaining of events that was produced and run by spades(). The sequence of steps in the workflow therefore arises from each module’s events and their scheduling, rather than being explicitly imposed by the user.\n\n\nCode\nSpaDES.core::completed(castorSim)\n\n\n    eventTime         moduleName          eventType eventPriority\n        &lt;num&gt;             &lt;char&gt;             &lt;char&gt;         &lt;num&gt;\n 1:         0         checkpoint               init             0\n 2:         0               save               init             0\n 3:         0           progress               init             0\n 4:         0               load               init             0\n 5:         0         dataCastor               init             1\n 6:         0 growingStockCastor               init             1\n 7:         0     blockingCastor               init             1\n 8:         0     forestryCastor               init             1\n....\n\n\nWe suggest omitting the blockingCastor module in setupProject() and rerunning the workflow again to see how spades is capable of re-generating a new workflow with little effort from the user.\n\n\nCode\nmodules &lt;- c(\"dataCastor\", \n             \"growingStockCastor\", \n             \"forestryCastor\")\n\nout &lt;- setupProject(\n  paths = list(\"inputPath\" = \"modules/forestryCastor/inputs\",\n               \"outputPath\" = \"/R/scenarios/comparison_stsm/outputs\",\n               \"modulePath\" = \"modules/\",\n               \"cachePath\" = \"modules/forestryCastor\",\n               \"projectPath\" = \"~/tutos/castorExample/\"),\n  modules = modules,\n  functions = \"bcgov/castor@main/R/functions/R_Postgres.R\",\n  ## install and load\n  require = \"dplyr\",\n  ## install but don't load these:\n  packages = c(\n    \"DBI\", \n    \"keyring\",\n    \"rgdal\", \n    \"RPostgreSQL\", \n    \"sp\",\n    \"terra\"\n  ),\n  params = \"params.R\",\n  times = list(start = 0, end = 20),\n  outputs = {\n    data.frame(objectName = c(\"harvestReport\",\n                              \"growingStockReport\"))\n  },\n  scenario = {\n    data.table(name = \"stsm_base_case\",\n               description = paste(\"Priority queue = oldest first. Adjacency constraint\",\n                                   \"= None. Includes roads (mst) and blocks (pre).\",\n                                   \"Harvest flow = 147,300 m3/year in decade 1, 133,500\",\n                                   \"m3/year in decade 2, 132,300 m3/year in decades 3 to\",\n                                   \"14 and 135,400 m3/year in decades 15 to 25.\",\n                                   \"Minimum harvest age = 80 and minimum harvest volume = 150\"))\n  },\n  harvestFlow = {\n    rbindlist(list(data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 1,\n                                                 to = 1, \n                                                 by = 1),\n                                            1), \n                              flow = 1473000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 2,\n                                                 to = 2, \n                                                 by = 1),\n                                            1), \n                              flow = 1335000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 3,\n                                                 to = 14, \n                                                 by = 1),\n                                            1), \n                              flow = 1323000, \n                              partition_type = 'live'),\n                   data.table(compartment = \"tsa99\",\n                              partition = ' age &gt; 79 AND vol &gt; 149 ', \n                              period = rep( seq (from = 15,\n                                                 to = 25, \n                                                 by = 1),\n                                            1), \n                              flow = 1354000, \n                              partition_type = 'live')  \n    ))\n  },\n  Restart = TRUE\n)\n\n## initialize and run simulation in one go\ncastorSim2 &lt;- do.call(SpaDES.core::simInitAndSpades, out)"
  },
  {
    "objectID": "castorExample.html#footnotes",
    "href": "castorExample.html#footnotes",
    "title": "7  Castor workflow with setupProject",
    "section": "",
    "text": "SpaDES.project is currently being adapted to deal with modules nested in folders of GitHub repositories (instead of living in their own GitHub repositories). Hence, the code in this example is subject to changes in the near future.↩︎\nUsing the googledrive R package. See ?googledrive::drive_auth for more information.↩︎\nSee also Chapter 4.↩︎"
  }
]